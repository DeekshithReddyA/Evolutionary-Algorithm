// ──────────────────────────────────────────────
//  NEAT trainer  –  wraps the neataptic library
// ──────────────────────────────────────────────

export class NEATTrainer {
  constructor(config) {
    if (typeof neataptic === 'undefined') {
      throw new Error(
        'neataptic library not loaded. Check your internet connection.',
      );
    }

    this.populationSize = config.populationSize || 50;
    this.mutationRate   = config.mutationRate   || 0.3;
    this.elitismCount   = config.elitismCount   || 5;
    this.inputSize      = config.inputSize      || 10;
    this.generation     = 0;

    this.neat = new neataptic.Neat(this.inputSize, 1, null, {
      popsize:      this.populationSize,
      mutationRate: this.mutationRate,
      elitism:      this.elitismCount,
      mutation: [
        neataptic.methods.mutation.ADD_NODE,
        neataptic.methods.mutation.SUB_NODE,
        neataptic.methods.mutation.ADD_CONN,
        neataptic.methods.mutation.SUB_CONN,
        neataptic.methods.mutation.MOD_WEIGHT,
        neataptic.methods.mutation.MOD_BIAS,
        neataptic.methods.mutation.MOD_ACTIVATION,
        neataptic.methods.mutation.ADD_GATE,
        neataptic.methods.mutation.SUB_GATE,
        neataptic.methods.mutation.ADD_SELF_CONN,
        neataptic.methods.mutation.SUB_SELF_CONN,
        neataptic.methods.mutation.ADD_BACK_CONN,
        neataptic.methods.mutation.SUB_BACK_CONN,
      ],
    });

    this._wrapPopulation();
  }

  // ── helpers ─────────────────────────────────
  /** Add a .decide() shim so the game engine can call brain.decide(). */
  _wrapPopulation() {
    for (const genome of this.neat.population) {
      if (!genome.decide) {
        genome.decide = (inputs) => genome.activate(inputs)[0] > 0.5;
      }
    }
  }

  getPopulation() {
    return this.neat.population;
  }

  // ── evolution ───────────────────────────────
  /**
   * @param {number[]} scores  same order as getPopulation()
   * @returns {{ fittest: object, generation: number }}
   */
  evolve(scores) {
    // assign scores
    for (let i = 0; i < this.neat.population.length; i++) {
      this.neat.population[i].score = scores[i] || 0;
    }

    this.neat.sort();
    const fittest = this.neat.getFittest();

    // ── build next generation ──
    const next = [];

    // elitism (direct references – these won't be mutated)
    for (let i = 0; i < this.neat.elitism && i < this.neat.population.length; i++) {
      next.push(this.neat.population[i]);
    }

    // offspring
    while (next.length < this.neat.popsize) {
      next.push(this.neat.getOffspring());
    }

    // mutate non-elites
    for (let i = this.neat.elitism; i < next.length; i++) {
      if (Math.random() < this.neat.mutationRate) {
        const methods = this.neat.mutation;
        const method  = methods[Math.floor(Math.random() * methods.length)];
        try { next[i].mutate(method); } catch (_) { /* topology may reject */ }
      }
    }

    this.neat.population = next;
    this.generation++;
    this._wrapPopulation();

    return { fittest, generation: this.generation };
  }

  getBest() {
    this.neat.sort();
    return this.neat.getFittest();
  }

  serializeBest() {
    const best = this.getBest();
    return best ? best.toJSON() : null;
  }

  static deserializeNetwork(json) {
    if (typeof neataptic === 'undefined') {
      throw new Error('neataptic library not loaded.');
    }
    const net = neataptic.Network.fromJSON(json);
    net.decide = (inputs) => net.activate(inputs)[0] > 0.5;
    return net;
  }
}
