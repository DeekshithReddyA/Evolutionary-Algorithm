// ──────────────────────────────────────────────
//  Genetic Algorithm  (fixed-topology NN brains)
// ──────────────────────────────────────────────
import { NeuralNetwork } from './nn.js';
import { getSelectionStrategy } from './selection.js';

export class GeneticAlgorithm {
  constructor(config) {
    this.populationSize  = config.populationSize  || 50;
    this.mutationRate    = config.mutationRate    || 0.1;
    this.crossoverRate   = config.crossoverRate   || 0.7;
    this.elitismCount    = config.elitismCount    || 5;
    this.inputSize       = config.inputSize       || 10;
    this.selectionStrategy = getSelectionStrategy(config.selectionStrategy);

    this.population = [];
    this.generation = 0;
  }

  /** Initialise random population. Returns the array of NNs. */
  createInitialPopulation() {
    this.population = [];
    for (let i = 0; i < this.populationSize; i++) {
      this.population.push(NeuralNetwork.fromInputSize(this.inputSize));
    }
    this.generation = 0;
    return this.population;
  }

  /**
   * Create next generation from fitness scores.
   * @param {number[]} fitnesses  same order as this.population
   * @returns {NeuralNetwork[]}  the new population
   */
  evolve(fitnesses) {
    // pair & sort descending
    const rated = this.population
      .map((nn, i) => ({ nn, fitness: fitnesses[i] }))
      .sort((a, b) => b.fitness - a.fitness);

    const next = [];

    // ── elitism ──
    const elites = Math.min(this.elitismCount, rated.length);
    for (let i = 0; i < elites; i++) next.push(rated[i].nn.clone());

    // ── select parents ──
    const parentCount = Math.max(2, Math.ceil(this.populationSize / 4));
    const parents = this.selectionStrategy.select(rated, parentCount);

    // ── breed ──
    while (next.length < this.populationSize) {
      const p1 = parents[Math.floor(Math.random() * parents.length)];
      const p2 = parents[Math.floor(Math.random() * parents.length)];

      let child;
      if (Math.random() < this.crossoverRate) {
        child = p1.nn.crossover(p2.nn);
      } else {
        child = p1.nn.clone();
      }
      child.mutate(this.mutationRate);
      next.push(child);
    }

    this.population = next;
    this.generation++;
    return this.population;
  }

  /** After evolve(), index 0 is always the elite copy. */
  getBest() {
    return this.population[0];
  }
}
